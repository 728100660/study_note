### 1 排序数组

​	排序数组中的搜索问题，首先想到 **二分法** 解决。

```java
/*统计一个数字在排序数组中出现的次数。*/
class Solution {
    public int search(int[] nums, int target) {
        int i = 0, j = nums.length - 1;
        //查询右边界，等号很重要
        //当数组元素比target小的时候，i一直往后挪，当nums[m]大于target的时候，i就定住不动了，因为nums是递增的，这时，j就减小，一直减小到与i相等，再-1，此时j在i的前一位，nums[j]<=target,nums[i]>target, 如果nums[j] ！= target， 则数组中没有target；
        while(i <= j){
            int m = (i + j)/2;
            if(nums[m] <= target) i = m + 1;
            else j = m - 1;
        }
        if(j>0 && nums[j] != target){
            return 0;
        }
        int right = i;
        i = 0;
        j = nums.length - 1;
        //查询左边界，注意这里没有等号了
        while(i <= j){
            int m = (i + j)/2;
            if(nums[m] < target) i = m + 1;
            else j = m - 1;
        }
        int left = i;
        return right - left;
    }
}
```

### 2 双向队列

```java
给定一个数组 nums 和滑动窗口的大小 k，请找出所有滑动窗口里的最大值。
class Solution {
    public int[] maxSlidingWindow(int[] nums, int k) {
        if(nums.length == 0 && k == 0) return new int[0];
        //构建一个双向队列结构，从左往右递减
        Deque<Integer> deque = new LinkedList<>();
        int[] res = new int[nums.length-k+1];
        for(int j = 0,i = 1 - k; j < nums.length; j++, i++){
            //滑动窗口滑动,首先删除左边的数据，
            //但是只有当i>0的时候才能滑动，不能是=0 因为这里是循环开始，
            //下标到0了，数据还没赋值上去
            //此时不能随便删除第一个，要判断这个元素是不是滑动窗口即将离开最左边的那个元素
            //如果不是，就说明这个元素还在滑动窗口中
            if(i > 0 && deque.peekFirst() == nums[i - 1]) deque.removeFirst();
            //遍历当前队列，将比下一个要插入的值小的数排除，但是这里不会增加复杂度，
            //每次循环队列数加一，如果这次while循环三次，那就是前面没有进while循环堆叠下来的
            while(!deque.isEmpty() && deque.peekLast() < nums[j]){
                deque.removeLast();
            }
            //判断完之后，deque中左边的数永远比下一个插入到右边的数大
            deque.addLast(nums[j]);
            //记录当前滑动窗口的最大值
            if(i>=0){
                res[i] = deque.peekFirst();  
            }
        }
        return res;
    }
}
```

