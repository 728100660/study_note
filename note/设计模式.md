## oop七大原则

- 开闭原则：对扩展开放，对修改关闭
- 里氏替换原则：继承必须保证超类所拥有的性质在子类中成立（尽量少多态）
- 依赖倒置性：要面向接口编程，不要面向实现编程（降低耦合性）
- 单一职责原则：控制类的颗粒度、将对象解耦、提高其内聚性（尽量让方法的功能更具体）
- 接口隔离原则：要为各个类建立他们专门需要的接口（精简单一）
- 迪米特法则：只与你的朋友（直接关系）交谈，不跟陌生人（间接关系）说话（通过第三方转发（降低耦合性））。
- 合成复用原则；尽量使用组合或者聚合的方式来关联，其次才考虑使用继承关系来实现（组合和聚合是什么？）

## 2 工厂模式

​	实现创建者和调用者分离

### 2.1 分类

- 简单工厂模式
- 工厂方法模式
- 抽象工厂模式

### 2.2 原则

- 开闭原则
- 依赖倒置性
- 迪米特法则

## 3 单例模式

### 	3.1 懒汉模式

​	

```java
public class SingleTest{
    //注意修饰符，private，不允许外部更改，static，在类被加载的时候只初始化一次
    private static SingleTest instance = null
    private SingleTest(){
    }
    public SingleTest getInstance(){
        //线程不安全，可能会出事，判断该类是否是第一次被调用
        if(instance!=null){
            return instance;
        }
        else{
            return new SingleTest();
        }
    }
}
```



### 	3.2 饿汉模式（好一点）

```java
public class SingleTest(){
    //注意修饰符，private，不允许外部更改，static，在类被加载的时候只初始化一次
    private static SingleTest instance = new SingleTest(){
    private SingleTest(){
    }
    public SingleTest getInstance(){
        return instance;
    }
    }
} 
```

## 4 原型模式

​	说白了就是浅拷贝深拷贝

​	继承cloneable接口，重写clone方法，ok之

## 5 builder建造者模式

```java
//建造者模式用于生产复杂对象


//复杂对象产品
class Product{
    private String partA;
    private String partB;
    private String partC;
    public setPartA(String partA){
        this.partA = partA;
    }
    //其他三个以此类推
    public void show(){
        System.out.println(partA + partB + partC);
    }
}

//指定任务完成得需求
class AbstractBuild{
    protected Product product = new Product();
    
    public Abstract buildPartA();
    public Abstract buildPartB();
    public Abstract buildPartC();
    

}

//工人，这个工人必须有完成这项工程的所有技能，但是每个工人的风格可以不同
class Builder extends AbstractBuild{
    public void buildPartA(){
        product.partA = '手';
    }
    public void buildPartB(){
        product.partB = '脚';
    }
    public void buildPartC(){
        product.partC = '头';
    }
}

//指挥者，不进行生产，完成组装
class Director{
    //指挥一个特定的工人过来建造，这个工人有自己的建造方式
    private Builer builder;
    
    public Director(Builder builder){
        this.builder = builder;
    }
    
    //指挥工人生产产品
    public Product getProduct(){
        builder.buildPartA();
        builder.buildPartB();
        builder.buildPartC();
        //参考上写的是rturn builder.getresult，getresult,是在builder抽象类中写的一个方法，也是返回product
        return builder.product;
    }
    
}


class client(){
    public static void main(String args[]){
        Product product;
        Builder builder = new Builder();
        Director director = new Director(builder);
        product = director.getProduct();
        product.show();
    }
}

```

## 6 观察者模式

##### ![image-20210108161650361](C:\Users\72810\AppData\Roaming\Typora\typora-user-images\image-20210108161650361.png)

```java
//1、抽象观察者
interface Company{
    public void response;
}
//2、具体观察者
class Company1 implements Company(){
    public void response(){
        System.out.println("company1做出的反应");
    }
}
//3、抽象目标
abstract AbstractObject{
    List<Company> companys = new LinkedList<Company>();
    
    public void add(Company company){
        company.add(Company);
    }
    
    public void remove(Company company){
        company.remove(company)
    }
    
    public abstract void change(int number);
    
}

//4、具体目标
class Rate extends AbstractObject{
    private static float rate = 1.2;
    public void change(float number){
        rate = number;
        for(company:companys){
            company.response;
        }
    }
    public void prtrate(){
        System.out.println(rate)
    }
}


//执行
class Excute{
    public static void main(String args[]){
        Rate rate = new Rate();
        Company company1 = new Company1;
        rate.add(Company);
        rate.change(1.6);
    }
}


```



## 7 适配器模式

​	模式的结构

- 目标（Target）接口: 当前系统业务所期待的接口，他可以是抽象类或者接口
- 适配者（Adaptee）类：他是被访问和适配的现存组件库中的组件接口
- 适配器（Adapter）类：他是一个转换器，通过继承或引用适配者对象，把适配者接口转换成目标接口，让客户按照目标接口的格式访问适配者。

```java
//在软件设计中也可能出现：需要开发的具有某种业务功能的组件在现有的组件库中已经存在，但它们与当前系统的接口规范不兼容，如果重新开发这些组件成本又很高，这时用适配器模式能很好地解决这些问题。
//适配器模式分两类
//1、类适配器模式

//目标接口
interface Target(){
    public void hello();
}


//适配者类（已存在的组件）
class Adaptee{
    //及其不规范的命名，所有要做适配
    public void hello_world(){
        System.out.println("hello world!");
    }
}


//适配器类（接口转换）
class Adapter extends Adaptee implements Target{
    public void hello(){
        hello_word();
    }
}

class client{
    public static void main(String args[]){
        Target target = new Adapter();
        target.hello;
    }
}
```

## 8 装饰模式

## 9 代理模式

主要角色

- 抽象主题（Subject）：通过接口或者抽象类声明真实主题和代理对象实现的业务方法
- 真实主题类（Real Subject）：实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的 对象
- 代理类(Proxy)类：提供了与真实主题相同的接口，其内部含有对真实主题的引用，他提供访问，扩展真实主题的功能

![image-20210108161528256](C:\Users\72810\AppData\Roaming\Typora\typora-user-images\image-20210108161528256.png)

```java
//虚拟主题
interface Subject{
	public void doSomething;
}

//真实主题
class RealSubject implements Subject{
    public void doSomething(){
        System.out.println("核心业务逻辑处理");
    }

}


//代理类
class Proxy implements SUbject{
    private Subject subject;
    public void Proxy(Subject subject){
        this.subject = subject;
    }
    
    public void doSomething(){
        //附加处理
        preDoSomething();
        //真实的主题中的核心业务逻辑代码
        subject.doSomething();
        
        //附加处理
        afterDoSomething;
    }
    
    private void preDoSomething(){
        System.out.println("处理前");
    }
    private void afterDoSomething(){
        System.out.println("处理后");
    }
}


//使用
public class HelloProxy{
    public static void main(String[] args){
        Subject subject = new Subject();
        
        Subject proxy = new Proxy(subject);
        proxy.doSomething();
        
        //这样写可能更好些
        Subject subject = new(Proxy(new Subject()));
        subject.doSomething();
    }
}
```

