## oop七大原则

- 开闭原则：对扩展开放，对修改关闭
- 里氏替换原则：继承必须保证超类所拥有的性质在子类中成立（尽量少多态）
- 依赖倒置性：要面向接口编程，不要面向实现编程（降低耦合性）
- 单一职责原则：控制类的颗粒度、将对象解耦、提高其内聚性（尽量让方法的功能更具体）
- 接口隔离原则：要为各个类建立他们专门需要的接口（精简单一）
- 迪米特法则：只与你的朋友（直接关系）交谈，不跟陌生人（间接关系）说话（通过第三方转发（降低耦合性））。
- 合成复用原则；尽量使用组合或者聚合的方式来关联，其次才考虑使用继承关系来实现（组合和聚合是什么？）

## 2 工厂模式

​	实现创建者和调用者分离

### 2.1 分类

- 简单工厂模式
- 工厂方法模式
- 抽象工厂模式

### 2.2 原则

- 开闭原则
- 依赖倒置性
- 迪米特法则

## 3 单例模式

### 	3.1 懒汉模式

​	

```java
public class SingleTest{
    //注意修饰符，private，不允许外部更改，static，在类被加载的时候只初始化一次
    private static SingleTest instance = null
    private SingleTest(){
    }
    public SingleTest getInstance(){
        //线程不安全，可能会出事，判断该类是否是第一次呗调用
        if(instance!=null){
            return instance;
        }
        else{
            return new SingleTest();
        }
    }
}
```



### 	3.2 饿汉模式（好一点）

```java
public class SingleTest(){
    //注意修饰符，private，不允许外部更改，static，在类被加载的时候只初始化一次
    private static SingleTest instance = new SingleTest(){
    private SingleTest(){
    }
    public SingleTest getInstance(){
        return instance;
    }
    }
} 
```

## 4 原型模式

​	说白了就是浅拷贝深拷贝

​	继承cloneable接口，重写clone方法，ok之

## 5 builder建造者模式

```java
//建造者模式用于生产复杂对象


//复杂对象产品
class Product{
    private String partA;
    private String partB;
    private String partC;
    public setPartA(String partA){
        this.partA = partA;
    }
    //其他三个以此类推
    public void show(){
        System.out.println(partA + partB + partC);
    }
}

//指定任务完成得需求
class AbstractBuild{
    protected Product product = new Product();
    
    public Abstract buildPartA();
    public Abstract buildPartB();
    public Abstract buildPartC();
    

}

//工人，这个工人必须有完成这项工程的所有技能，但是每个工人的风格可以不同
class Builder extends AbstractBuild{
    public void buildPartA(){
        product.partA = '手';
    }
    public void buildPartB(){
        product.partB = '脚';
    }
    public void buildPartC(){
        product.partC = '头';
    }
}

//指挥者，不进行生产，完成组装
class Director{
    //指挥一个特定的工人过来建造，这个工人有自己的建造方式
    private Builer builder;
    
    public Director(Builder builder){
        this.builder = builder;
    }
    
    //指挥工人生产产品
    public Product getProduct(){
        builder.buildPartA();
        builder.buildPartB();
        builder.buildPartC();
        //参考上写的是rturn builder.getresult，getresult,是在builder抽象类中写的一个方法，也是返回product
        return builder.product;
    }
    
}


class client(){
    public static void main(String args[]){
        Product product;
        Builder builder = new Builder();
        Director director = new Director(builder);
        product = director.getProduct();
        product.show();
    }
}

```

## 6 观察者模式

## 7 适配器模式

​	模式的结构

- 目标（Target）接口: 当前系统业务所期待的接口，他可以是抽象类或者接口
- 适配者（Adaptee）类：他是被访问和适配的现存组件库中的组件接口
- 适配器（Adapter）类：他是一个转换器，通过继承或引用适配者对象，把适配者接口转换成目标接口，让客户按照目标接口的格式访问适配者。

```java
//在软件设计中也可能出现：需要开发的具有某种业务功能的组件在现有的组件库中已经存在，但它们与当前系统的接口规范不兼容，如果重新开发这些组件成本又很高，这时用适配器模式能很好地解决这些问题。
//适配器模式分两类
//1、类适配器模式

//目标接口
interface Target(){
    public void hello();
}


//适配者类（已存在的组件）
class Adaptee{
    //及其不规范的命名，所有要做适配
    public void hello_world(){
        System.out.println("hello world!");
    }
}


//适配器类（接口转换）
class Adapter extends Adaptee implements Target{
    public void hello(){
        hello_word();
    }
}

class client{
    public static void main(String args[]){
        Target target = new Adapter();
        target.hello;
    }
}
```



## 8 装饰模式